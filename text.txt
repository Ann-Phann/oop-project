#include <SFML/Graphics.hpp>
#include <array>

const int ROWS = 6;
const int COLS = 7;
const int SCREEN_WIDTH = 1280;
const int SCREEN_HEIGHT = 700;
const int BLOCK_WIDTH = SCREEN_WIDTH / COLS;
const int BLOCK_HEIGHT = SCREEN_HEIGHT / ROWS;

class Block {
public:
    sf::RectangleShape shape;
    Block(float x, float y) {
        shape.setSize(sf::Vector2f(BLOCK_WIDTH, BLOCK_HEIGHT));
        shape.setPosition(x, y);
        shape.setFillColor(sf::Color::Blue); // Example color
    }
    void draw(sf::RenderWindow& window) {
        window.draw(shape);
    }
};

class Game {
    std::array<std::array<Block*, COLS>, ROWS> blocks;

public:
    Game() {
        for (auto& row : blocks) {
            for (auto& block : row) {
                block = nullptr;
            }
        }
    }

    ~Game() {
        for (auto& row : blocks) {
            for (auto& block : row) {
                delete block;
            }
        }
    }

    void createNewRow() {
        // Shift rows down
        for (int i = ROWS - 1; i > 0; --i) {
            for (int j = 0; j < COLS; ++j) {
                blocks[i][j] = blocks[i - 1][j];
            }
        }
        // Create new top row
        for (int j = 0; j < COLS; ++j) {
            blocks[0][j] = new Block(j * BLOCK_WIDTH, 0);
        }
        updateBlockPositions();
    }

    void updateBlockPositions() {
        for (int i = 0; i < ROWS; ++i) {
            for (int j = 0; j < COLS; ++j) {
                if (blocks[i][j]) {
                    blocks[i][j]->shape.setPosition(j * BLOCK_WIDTH, i * BLOCK_HEIGHT);
                }
            }
        }
    }

    void draw(sf::RenderWindow& window) {
        for (auto& row : blocks) {
            for (auto& block : row) {
                if (block) {
                    block->draw(window);
                }
            }
        }
    }
};

int main() {
    sf::RenderWindow window(sf::VideoMode(SCREEN_WIDTH, SCREEN_HEIGHT), "Block Game");

    Game game;
    game.createNewRow(); // Create initial row
    bool spacePressed = false; // To track space key press state

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) {
                window.close();
            }
        }

        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Space)) {
            if (!spacePressed) {
                game.createNewRow();
                spacePressed = true; // Set flag to true when space is pressed
            }
        } else {
            spacePressed = false; // Reset flag when space is released
        }

        window.clear();
        game.draw(window);
        window.display();
    }

    return 0;
}
